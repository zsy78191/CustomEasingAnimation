{
  "name": "Customeasinganimation",
  "tagline": "A simple function to make bezier animation.",
  "body": "# CustomEasingAnimation\r\nA simple function to make bezier animation.\r\n这一段代码，可以通用于三次贝塞尔缓动动画。\r\n\r\n比如下段代码，将view平移了250px，并且动态改变label的文字。\r\n```objc\r\n[CustomEasingAnimation easingFrom:0 to:250 interval:1 timing:[CAMediaTimingFunction functionWithControlPoints:1 :0 :.5 :1.51] block:^(CGFloat value) {\r\n        view.transform = CGAffineTransformMakeTranslation(value, 0);\r\n        label.text = [NSString stringWithFormat:@\"%.2f\",value];\r\n} comeplte:^{\r\n       \r\n}];\r\n```\r\ndemo效果\r\n\r\n![](https://raw.githubusercontent.com/zsy78191/CustomEasingAnimation/master/timing.gif)\r\n\r\n# 缓动动画 （Easing Animation）\r\n\r\n缓动动画是目前iOS系统中非常常见的一类动画，大家一定不陌生。例如CocoaTouch框架中`CASpringAnimation`，是一种弹簧缓动动画，再比如`POP`框架的`POPSpringAnimation`，也是一种弹簧缓动动画，他们的效果如下：\r\n\r\n![](https://segmentfault.com/img/bVstTb)\r\n\r\n 当然`弹簧动画`是一种特殊的缓动动画，我们更常见的是根据bezier（贝赛尔）曲线构建的三次贝塞尔缓动动画。如果你不知道我在说啥，请看[Animations开源动效分析（二）POP-Stroke动画\r\n](https://segmentfault.com/a/1190000004365988)\r\n \r\n#bezier 曲线\r\n\r\nbezier曲线我在大学中并没有接触过，估计学过计算机图学的朋友一定很熟悉，这里就不详细介绍了。简单说就是一条曲线，由起点、终点和两个控制点决定的一条曲线。在我们的缓动动画中，这条曲线决定了动画的效果。并且简化为起点在(0,0)，终点在(1,1)的一条曲线，所以这条曲线只由两个控制点决定。\r\n\r\n这个曲线在Cocoa中对应的就是`CAMediaTimingFunction`类，下图是用一个开源软件生成的，软件地址是[keefo/CATweaker](https://github.com/keefo/CATweaker)。\r\n\r\n![](https://segmentfault.com/img/bVstNN)\r\n\r\n```objc\r\n/* Creates a timing function modelled on a cubic Bezier curve. The end\r\n * points of the curve are at (0,0) and (1,1), the two points 'c1' and\r\n * 'c2' defined by the class instance are the control points. Thus the\r\n * points defining the Bezier curve are: '[(0,0), c1, c2, (1,1)]' */\r\n\r\n+ (instancetype)functionWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;\r\n\r\n- (instancetype)initWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;\r\n```\r\n \r\n传入的四个值，就是两个控制点的x，y坐标。范围是[0,1]。\r\n\r\n#常见的Easing\r\n\r\n常见的Easing有如下几种，你一定见过\r\n\r\n* linear 直线\r\n* easeIn 缓入\r\n* easeOut 缓出\r\n* easeInOut 缓出缓入\r\n\r\n#bezier曲线填充\r\n\r\n所谓的`填充`，就是通过bezier方程，根据x计算y的过程。比如在[0,1]区间内，取100个等距x值，对应计算y值，将这些点绘制再坐标轴上，x取得越多，整个点组成的曲线月平滑，却趋近于bezier曲线。\r\n\r\n在我们做动画时，考虑到计时器（CADisplayLink）的刷新频率是60帧/秒，所以采样个数根据动画时长x频率决定。\r\n\r\n首先来计算采样点，这段算法是我从wiki上搬过来的，数学渣伤不起。\r\n\r\n头文件\r\n```c\r\n#ifndef bezier_h\r\n#define bezier_h\r\n\r\n#include <stdio.h>\r\n\r\n/*\r\n 產生三次方貝茲曲線的程式碼\r\n */\r\n\r\ntypedef struct\r\n{\r\n    float x;\r\n    float y;\r\n}\r\nPoint2D;\r\nPoint2D PointOnCubicBezier( Point2D* cp, float t );\r\nvoid ComputeBezier( Point2D* cp, int numberOfPoints, Point2D* curve );\r\n\r\n#endif /* bezier_h */\r\n```\r\n\r\nc文件\r\n```c\r\n#include \"bezier.h\"\r\n\r\n/*\r\n cp在此是四個元素的陣列:\r\n cp[0]為起始點，或上圖中的P0\r\n cp[1]為第一個控制點，或上圖中的P1\r\n cp[2]為第二個控制點，或上圖中的P2\r\n cp[3]為結束點，或上圖中的P3\r\n t為參數值，0 <= t <= 1\r\n */\r\n\r\nPoint2D PointOnCubicBezier( Point2D* cp, float t )\r\n{\r\n    float   ax, bx, cx;\r\n    float   ay, by, cy;\r\n    float   tSquared, tCubed;\r\n    Point2D result;\r\n    \r\n    /*計算多項式係數*/\r\n    \r\n    cx = 3.0 * (cp[1].x - cp[0].x);\r\n    bx = 3.0 * (cp[2].x - cp[1].x) - cx;\r\n    ax = cp[3].x - cp[0].x - cx - bx;\r\n    \r\n    cy = 3.0 * (cp[1].y - cp[0].y);\r\n    by = 3.0 * (cp[2].y - cp[1].y) - cy;\r\n    ay = cp[3].y - cp[0].y - cy - by;\r\n    \r\n    /*計算位於參數值t的曲線點*/\r\n    \r\n    tSquared = t * t;\r\n    tCubed = tSquared * t;\r\n    \r\n    result.x = (ax * tCubed) + (bx * tSquared) + (cx * t) + cp[0].x;\r\n    result.y = (ay * tCubed) + (by * tSquared) + (cy * t) + cp[0].y;\r\n    \r\n    return result;\r\n}\r\n\r\n/*\r\n ComputeBezier以控制點cp所產生的曲線點，填入Point2D結構的陣列。\r\n 呼叫者必須分配足夠的記憶體以供輸出結果，其為<sizeof(Point2D) numberOfPoints>\r\n */\r\n\r\nvoid ComputeBezier( Point2D* cp, int numberOfPoints, Point2D* curve )\r\n{\r\n    float   dt;\r\n    int    i;\r\n    dt = 1.0 / ( numberOfPoints - 1 );\r\n    for( i = 0; i < numberOfPoints; i++)\r\n        curve[i] = PointOnCubicBezier( cp, i*dt );\r\n}\r\n```\r\n首先佩服数学好的大牛们，也感谢写代码的前辈们，我们通过上面这段代码来计算bezier采样点\r\n\r\n```objc\r\n+ (NSArray *)calculateFrameFromValue:(CGFloat)fromValue toValue:(CGFloat)toValue timing:(CAMediaTimingFunction *)function frameCount:(size_t)frameCount\r\n{\r\n    float p[4][2];\r\n    Point2D cp[4];\r\n    \r\n    for (int i = 0; i < 4; ++i) {\r\n        [function getControlPointAtIndex:i values:p[i]];\r\n        //        NSLog(@\"{%f,%f}\",p[i][0],p[i][1]);\r\n        cp[i].x = p[i][0];\r\n        cp[i].y = p[i][1];\r\n    }\r\n    \r\n    Point2D* curve = (Point2D*)malloc(frameCount * sizeof(Point2D));\r\n    ComputeBezier(cp, (int)frameCount, curve);\r\n    \r\n    NSMutableArray* array = [NSMutableArray array];\r\n    for (int i = 0; i < frameCount; ++i) {\r\n        //        NSLog(@\"{%f,%f}\",curve[i].x,curve[i].y);\r\n        [array addObject:@(curve[i].y * (toValue - fromValue) + fromValue)];\r\n    }\r\n    \r\n    free(curve);\r\n    \r\n    return [array copy];\r\n}\r\n```\r\n我们将`CAMediaTimingFunction`的两个控制点转成Point2D结构体，得到采样点的Y坐标数组，最后根据起点终点计算属性点，返回。\r\n\r\n#动起来\r\n\r\n获得位置数据以后，我们让他动起来\r\n\r\n```objc\r\n@interface CustomEasingAnimation()\r\n{\r\n    int _count;\r\n    int _total;\r\n}\r\n@property (nonatomic, strong) CADisplayLink* link;\r\n@property (nonatomic, strong) void (^ block)(CGFloat value);\r\n@property (nonatomic, strong) void (^ finish) ();\r\n@property (nonatomic, strong) NSArray* data;\r\n@end\r\n``` \r\n\r\n这里要用到就是`CADisplayLink`类，进行计时。\r\n\r\n```objc\r\n+ (void)easingFrom:(CGFloat)fromValue to:(CGFloat)toValue interval:(NSTimeInterval)interval timing:(CAMediaTimingFunction *)function block:(void (^)(CGFloat))block comeplte:(void (^)(void))finish\r\n{\r\n    CustomEasingAnimation* e = [[CustomEasingAnimation alloc] init];\r\n    e.link = [CADisplayLink displayLinkWithTarget:e selector:@selector(tick:)];\r\n    [e.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\r\n    e.block = block;\r\n    e.data = [[self class] calculateFrameFromValue:fromValue toValue:toValue timing:function frameCount:interval * 60 / e.link.frameInterval];\r\n    e.finish = finish;\r\n}\r\n\r\n- (void)setData:(NSArray *)data\r\n{\r\n    _data = data;\r\n    _total = (int)data.count;\r\n    _count = 0;\r\n}\r\n\r\n- (void)tick:(CADisplayLink*)sender\r\n{\r\n    if (_count < _total) {\r\n        if (self.block) {\r\n            self.block([self.data[_count] doubleValue]);\r\n        }\r\n        _count ++;\r\n    }\r\n    else\r\n    {\r\n        if (self.finish) {\r\n            self.finish();\r\n        }\r\n        [sender invalidate];\r\n    }\r\n}\r\n```\r\n代码就不详尽解释了，没有什么难点（难的wiki拿来的代码都搞定了，那段代码我也看不懂，主要不懂bezier方程计算），有疑问可以留言。\r\n\r\n其实整个功能，[POP](https://github.com/facebook/pop)和[Advance](https://github.com/storehouse/Advance)（一个新的swfit动画框架，非常屌）都有相关功能，但这两个框架比较比较重量级，所以如果只是需要用到一些简单功能可以选择我哦。\t\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}